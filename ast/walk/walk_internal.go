// Code generated by tools/gen-ast-walk; DO NOT EDIT.

package walk

import (
	"github.com/cloudspannerecosystem/memefish/ast"
)

func walkInternal(node ast.Node, v Visitor, stack []*stackItem) []*stackItem {
	switch n := node.(type) {
	case *ast.BadNode:
		// nothing to do

	case *ast.BadStatement:
		stack = append(stack, &stackItem{node: n.BadNode, visitor: v})

	case *ast.BadQueryExpr:
		stack = append(stack, &stackItem{node: n.BadNode, visitor: v})

	case *ast.BadExpr:
		stack = append(stack, &stackItem{node: n.BadNode, visitor: v})

	case *ast.BadType:
		stack = append(stack, &stackItem{node: n.BadNode, visitor: v})

	case *ast.BadDDL:
		stack = append(stack, &stackItem{node: n.BadNode, visitor: v})

	case *ast.BadDML:
		stack = append(stack, &stackItem{node: n.BadNode, visitor: v})

	case *ast.QueryStatement:
		stack = append(stack, &stackItem{node: n.Query, visitor: v})
		stack = append(stack, &stackItem{node: n.Hint, visitor: v})

	case *ast.Query:
		for i := len(n.PipeOperators) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.PipeOperators[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.Limit, visitor: v})
		stack = append(stack, &stackItem{node: n.OrderBy, visitor: v})
		stack = append(stack, &stackItem{node: n.Query, visitor: v})
		stack = append(stack, &stackItem{node: n.With, visitor: v})

	case *ast.Hint:
		for i := len(n.Records) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Records[i], visitor: v})
		}

	case *ast.HintRecord:
		stack = append(stack, &stackItem{node: n.Value, visitor: v})
		stack = append(stack, &stackItem{node: n.Key, visitor: v})

	case *ast.With:
		for i := len(n.CTEs) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.CTEs[i], visitor: v})
		}

	case *ast.CTE:
		stack = append(stack, &stackItem{node: n.QueryExpr, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.Select:
		stack = append(stack, &stackItem{node: n.Having, visitor: v})
		stack = append(stack, &stackItem{node: n.GroupBy, visitor: v})
		stack = append(stack, &stackItem{node: n.Where, visitor: v})
		stack = append(stack, &stackItem{node: n.From, visitor: v})
		for i := len(n.Results) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Results[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.As, visitor: v})

	case *ast.AsStruct:
		// nothing to do

	case *ast.AsValue:
		// nothing to do

	case *ast.AsTypeName:
		stack = append(stack, &stackItem{node: n.TypeName, visitor: v})

	case *ast.FromQuery:
		stack = append(stack, &stackItem{node: n.From, visitor: v})

	case *ast.CompoundQuery:
		for i := len(n.Queries) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Queries[i], visitor: v})
		}

	case *ast.SubQuery:
		stack = append(stack, &stackItem{node: n.Query, visitor: v})

	case *ast.StarModifierExcept:
		for i := len(n.Columns) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Columns[i], visitor: v})
		}

	case *ast.StarModifierReplaceItem:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.StarModifierReplace:
		for i := len(n.Columns) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Columns[i], visitor: v})
		}

	case *ast.Star:
		stack = append(stack, &stackItem{node: n.Replace, visitor: v})
		stack = append(stack, &stackItem{node: n.Except, visitor: v})

	case *ast.DotStar:
		stack = append(stack, &stackItem{node: n.Replace, visitor: v})
		stack = append(stack, &stackItem{node: n.Except, visitor: v})
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.Alias:
		stack = append(stack, &stackItem{node: n.As, visitor: v})
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.AsAlias:
		stack = append(stack, &stackItem{node: n.Alias, visitor: v})

	case *ast.ExprSelectItem:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.From:
		stack = append(stack, &stackItem{node: n.Source, visitor: v})

	case *ast.Where:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.GroupBy:
		for i := len(n.Exprs) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Exprs[i], visitor: v})
		}

	case *ast.Having:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.OrderBy:
		for i := len(n.Items) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Items[i], visitor: v})
		}

	case *ast.OrderByItem:
		stack = append(stack, &stackItem{node: n.Collate, visitor: v})
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.Collate:
		stack = append(stack, &stackItem{node: n.Value, visitor: v})

	case *ast.Limit:
		stack = append(stack, &stackItem{node: n.Offset, visitor: v})
		stack = append(stack, &stackItem{node: n.Count, visitor: v})

	case *ast.Offset:
		stack = append(stack, &stackItem{node: n.Value, visitor: v})

	case *ast.PipeSelect:
		for i := len(n.Results) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Results[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.As, visitor: v})

	case *ast.PipeWhere:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.Unnest:
		stack = append(stack, &stackItem{node: n.Sample, visitor: v})
		stack = append(stack, &stackItem{node: n.WithOffset, visitor: v})
		stack = append(stack, &stackItem{node: n.As, visitor: v})
		stack = append(stack, &stackItem{node: n.Hint, visitor: v})
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.WithOffset:
		stack = append(stack, &stackItem{node: n.As, visitor: v})

	case *ast.TableName:
		stack = append(stack, &stackItem{node: n.Sample, visitor: v})
		stack = append(stack, &stackItem{node: n.As, visitor: v})
		stack = append(stack, &stackItem{node: n.Hint, visitor: v})
		stack = append(stack, &stackItem{node: n.Table, visitor: v})

	case *ast.PathTableExpr:
		stack = append(stack, &stackItem{node: n.Sample, visitor: v})
		stack = append(stack, &stackItem{node: n.WithOffset, visitor: v})
		stack = append(stack, &stackItem{node: n.As, visitor: v})
		stack = append(stack, &stackItem{node: n.Hint, visitor: v})
		stack = append(stack, &stackItem{node: n.Path, visitor: v})

	case *ast.SubQueryTableExpr:
		stack = append(stack, &stackItem{node: n.Sample, visitor: v})
		stack = append(stack, &stackItem{node: n.As, visitor: v})
		stack = append(stack, &stackItem{node: n.Query, visitor: v})

	case *ast.ParenTableExpr:
		stack = append(stack, &stackItem{node: n.Sample, visitor: v})
		stack = append(stack, &stackItem{node: n.Source, visitor: v})

	case *ast.Join:
		stack = append(stack, &stackItem{node: n.Cond, visitor: v})
		stack = append(stack, &stackItem{node: n.Right, visitor: v})
		stack = append(stack, &stackItem{node: n.Left, visitor: v})
		stack = append(stack, &stackItem{node: n.Hint, visitor: v})

	case *ast.On:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.Using:
		for i := len(n.Idents) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Idents[i], visitor: v})
		}

	case *ast.TableSample:
		stack = append(stack, &stackItem{node: n.Size, visitor: v})

	case *ast.TableSampleSize:
		stack = append(stack, &stackItem{node: n.Value, visitor: v})

	case *ast.BinaryExpr:
		stack = append(stack, &stackItem{node: n.Right, visitor: v})
		stack = append(stack, &stackItem{node: n.Left, visitor: v})

	case *ast.UnaryExpr:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.InExpr:
		stack = append(stack, &stackItem{node: n.Right, visitor: v})
		stack = append(stack, &stackItem{node: n.Left, visitor: v})

	case *ast.UnnestInCondition:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.SubQueryInCondition:
		stack = append(stack, &stackItem{node: n.Query, visitor: v})

	case *ast.ValuesInCondition:
		for i := len(n.Exprs) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Exprs[i], visitor: v})
		}

	case *ast.IsNullExpr:
		stack = append(stack, &stackItem{node: n.Left, visitor: v})

	case *ast.IsBoolExpr:
		stack = append(stack, &stackItem{node: n.Left, visitor: v})

	case *ast.BetweenExpr:
		stack = append(stack, &stackItem{node: n.RightEnd, visitor: v})
		stack = append(stack, &stackItem{node: n.RightStart, visitor: v})
		stack = append(stack, &stackItem{node: n.Left, visitor: v})

	case *ast.SelectorExpr:
		stack = append(stack, &stackItem{node: n.Ident, visitor: v})
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.IndexExpr:
		stack = append(stack, &stackItem{node: n.Index, visitor: v})
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.SubscriptSpecifierKeyword:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.CallExpr:
		stack = append(stack, &stackItem{node: n.Hint, visitor: v})
		stack = append(stack, &stackItem{node: n.Having, visitor: v})
		stack = append(stack, &stackItem{node: n.NullHandling, visitor: v})
		for i := len(n.NamedArgs) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.NamedArgs[i], visitor: v})
		}
		for i := len(n.Args) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Args[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.Func, visitor: v})

	case *ast.TVFCallExpr:
		stack = append(stack, &stackItem{node: n.Sample, visitor: v})
		stack = append(stack, &stackItem{node: n.Hint, visitor: v})
		for i := len(n.NamedArgs) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.NamedArgs[i], visitor: v})
		}
		for i := len(n.Args) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Args[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.ExprArg:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.IntervalArg:
		stack = append(stack, &stackItem{node: n.Unit, visitor: v})
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.SequenceArg:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.LambdaArg:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})
		for i := len(n.Args) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Args[i], visitor: v})
		}

	case *ast.ModelArg:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.TableArg:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.NamedArg:
		stack = append(stack, &stackItem{node: n.Value, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.IgnoreNulls:
		// nothing to do

	case *ast.RespectNulls:
		// nothing to do

	case *ast.HavingMax:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.HavingMin:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.CountStarExpr:
		// nothing to do

	case *ast.ExtractExpr:
		stack = append(stack, &stackItem{node: n.AtTimeZone, visitor: v})
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})
		stack = append(stack, &stackItem{node: n.Part, visitor: v})

	case *ast.ReplaceFieldsArg:
		stack = append(stack, &stackItem{node: n.Field, visitor: v})
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.ReplaceFieldsExpr:
		for i := len(n.Fields) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Fields[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.AtTimeZone:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.WithExprVar:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.WithExpr:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})
		for i := len(n.Vars) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Vars[i], visitor: v})
		}

	case *ast.CastExpr:
		stack = append(stack, &stackItem{node: n.Type, visitor: v})
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.CaseExpr:
		stack = append(stack, &stackItem{node: n.Else, visitor: v})
		for i := len(n.Whens) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Whens[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.CaseWhen:
		stack = append(stack, &stackItem{node: n.Then, visitor: v})
		stack = append(stack, &stackItem{node: n.Cond, visitor: v})

	case *ast.CaseElse:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.IfExpr:
		stack = append(stack, &stackItem{node: n.ElseResult, visitor: v})
		stack = append(stack, &stackItem{node: n.TrueResult, visitor: v})
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.ParenExpr:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.ScalarSubQuery:
		stack = append(stack, &stackItem{node: n.Query, visitor: v})

	case *ast.ArraySubQuery:
		stack = append(stack, &stackItem{node: n.Query, visitor: v})

	case *ast.ExistsSubQuery:
		stack = append(stack, &stackItem{node: n.Query, visitor: v})
		stack = append(stack, &stackItem{node: n.Hint, visitor: v})

	case *ast.Param:
		// nothing to do

	case *ast.Ident:
		// nothing to do

	case *ast.Path:
		for i := len(n.Idents) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Idents[i], visitor: v})
		}

	case *ast.ArrayLiteral:
		for i := len(n.Values) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Values[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.Type, visitor: v})

	case *ast.TupleStructLiteral:
		for i := len(n.Values) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Values[i], visitor: v})
		}

	case *ast.TypedStructLiteral:
		for i := len(n.Values) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Values[i], visitor: v})
		}
		for i := len(n.Fields) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Fields[i], visitor: v})
		}

	case *ast.TypelessStructLiteral:
		for i := len(n.Values) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Values[i], visitor: v})
		}

	case *ast.NullLiteral:
		// nothing to do

	case *ast.BoolLiteral:
		// nothing to do

	case *ast.IntLiteral:
		// nothing to do

	case *ast.FloatLiteral:
		// nothing to do

	case *ast.StringLiteral:
		// nothing to do

	case *ast.BytesLiteral:
		// nothing to do

	case *ast.DateLiteral:
		stack = append(stack, &stackItem{node: n.Value, visitor: v})

	case *ast.TimestampLiteral:
		stack = append(stack, &stackItem{node: n.Value, visitor: v})

	case *ast.NumericLiteral:
		stack = append(stack, &stackItem{node: n.Value, visitor: v})

	case *ast.JSONLiteral:
		stack = append(stack, &stackItem{node: n.Value, visitor: v})

	case *ast.NewConstructor:
		for i := len(n.Args) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Args[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.Type, visitor: v})

	case *ast.BracedNewConstructor:
		stack = append(stack, &stackItem{node: n.Body, visitor: v})
		stack = append(stack, &stackItem{node: n.Type, visitor: v})

	case *ast.BracedConstructor:
		for i := len(n.Fields) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Fields[i], visitor: v})
		}

	case *ast.BracedConstructorField:
		stack = append(stack, &stackItem{node: n.Value, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.BracedConstructorFieldValueExpr:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.SimpleType:
		// nothing to do

	case *ast.ArrayType:
		stack = append(stack, &stackItem{node: n.Item, visitor: v})

	case *ast.StructType:
		for i := len(n.Fields) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Fields[i], visitor: v})
		}

	case *ast.StructField:
		stack = append(stack, &stackItem{node: n.Type, visitor: v})
		stack = append(stack, &stackItem{node: n.Ident, visitor: v})

	case *ast.NamedType:
		for i := len(n.Path) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Path[i], visitor: v})
		}

	case *ast.CastIntValue:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.CastNumValue:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.Options:
		for i := len(n.Records) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Records[i], visitor: v})
		}

	case *ast.OptionsDef:
		stack = append(stack, &stackItem{node: n.Value, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.CreateSchema:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.DropSchema:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.CreateDatabase:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.AlterDatabase:
		stack = append(stack, &stackItem{node: n.Options, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.CreatePlacement:
		stack = append(stack, &stackItem{node: n.Options, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.ProtoBundleTypes:
		for i := len(n.Types) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Types[i], visitor: v})
		}

	case *ast.CreateProtoBundle:
		stack = append(stack, &stackItem{node: n.Types, visitor: v})

	case *ast.AlterProtoBundle:
		stack = append(stack, &stackItem{node: n.Delete, visitor: v})
		stack = append(stack, &stackItem{node: n.Update, visitor: v})
		stack = append(stack, &stackItem{node: n.Insert, visitor: v})

	case *ast.AlterProtoBundleInsert:
		stack = append(stack, &stackItem{node: n.Types, visitor: v})

	case *ast.AlterProtoBundleUpdate:
		stack = append(stack, &stackItem{node: n.Types, visitor: v})

	case *ast.AlterProtoBundleDelete:
		stack = append(stack, &stackItem{node: n.Types, visitor: v})

	case *ast.DropProtoBundle:
		// nothing to do

	case *ast.CreateTable:
		stack = append(stack, &stackItem{node: n.RowDeletionPolicy, visitor: v})
		stack = append(stack, &stackItem{node: n.Cluster, visitor: v})
		for i := len(n.Synonyms) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Synonyms[i], visitor: v})
		}
		for i := len(n.PrimaryKeys) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.PrimaryKeys[i], visitor: v})
		}
		for i := len(n.TableConstraints) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.TableConstraints[i], visitor: v})
		}
		for i := len(n.Columns) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Columns[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.Synonym:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.CreateSequence:
		stack = append(stack, &stackItem{node: n.Options, visitor: v})
		for i := len(n.Params) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Params[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.SkipRange:
		stack = append(stack, &stackItem{node: n.Max, visitor: v})
		stack = append(stack, &stackItem{node: n.Min, visitor: v})

	case *ast.StartCounterWith:
		stack = append(stack, &stackItem{node: n.Counter, visitor: v})

	case *ast.BitReversedPositive:
		// nothing to do

	case *ast.ColumnDef:
		stack = append(stack, &stackItem{node: n.Options, visitor: v})
		stack = append(stack, &stackItem{node: n.DefaultSemantics, visitor: v})
		stack = append(stack, &stackItem{node: n.Type, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.ColumnDefaultExpr:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.GeneratedColumnExpr:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.IdentityColumn:
		for i := len(n.Params) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Params[i], visitor: v})
		}

	case *ast.TableConstraint:
		stack = append(stack, &stackItem{node: n.Constraint, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.ForeignKey:
		for i := len(n.ReferenceColumns) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.ReferenceColumns[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.ReferenceTable, visitor: v})
		for i := len(n.Columns) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Columns[i], visitor: v})
		}

	case *ast.Check:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.IndexKey:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.Cluster:
		stack = append(stack, &stackItem{node: n.TableName, visitor: v})

	case *ast.CreateRowDeletionPolicy:
		stack = append(stack, &stackItem{node: n.RowDeletionPolicy, visitor: v})

	case *ast.RowDeletionPolicy:
		stack = append(stack, &stackItem{node: n.NumDays, visitor: v})
		stack = append(stack, &stackItem{node: n.ColumnName, visitor: v})

	case *ast.CreateView:
		stack = append(stack, &stackItem{node: n.Query, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.DropView:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.AlterTable:
		stack = append(stack, &stackItem{node: n.TableAlteration, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.AlterIndex:
		stack = append(stack, &stackItem{node: n.IndexAlteration, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.AlterSequence:
		stack = append(stack, &stackItem{node: n.NoSkipRange, visitor: v})
		stack = append(stack, &stackItem{node: n.SkipRange, visitor: v})
		stack = append(stack, &stackItem{node: n.RestartCounterWith, visitor: v})
		stack = append(stack, &stackItem{node: n.Options, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.AlterChangeStream:
		stack = append(stack, &stackItem{node: n.ChangeStreamAlteration, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.AddSynonym:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.DropSynonym:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.RenameTo:
		stack = append(stack, &stackItem{node: n.AddSynonym, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.AddColumn:
		stack = append(stack, &stackItem{node: n.Column, visitor: v})

	case *ast.AddTableConstraint:
		stack = append(stack, &stackItem{node: n.TableConstraint, visitor: v})

	case *ast.AddRowDeletionPolicy:
		stack = append(stack, &stackItem{node: n.RowDeletionPolicy, visitor: v})

	case *ast.DropColumn:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.DropConstraint:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.DropRowDeletionPolicy:
		// nothing to do

	case *ast.ReplaceRowDeletionPolicy:
		stack = append(stack, &stackItem{node: n.RowDeletionPolicy, visitor: v})

	case *ast.SetOnDelete:
		// nothing to do

	case *ast.AlterColumn:
		stack = append(stack, &stackItem{node: n.Alteration, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.AlterColumnType:
		stack = append(stack, &stackItem{node: n.DefaultExpr, visitor: v})
		stack = append(stack, &stackItem{node: n.Type, visitor: v})

	case *ast.AlterColumnSetOptions:
		stack = append(stack, &stackItem{node: n.Options, visitor: v})

	case *ast.AlterColumnSetDefault:
		stack = append(stack, &stackItem{node: n.DefaultExpr, visitor: v})

	case *ast.AlterColumnDropDefault:
		// nothing to do

	case *ast.AlterColumnAlterIdentity:
		stack = append(stack, &stackItem{node: n.Alteration, visitor: v})

	case *ast.RestartCounterWith:
		stack = append(stack, &stackItem{node: n.Counter, visitor: v})

	case *ast.SetSkipRange:
		stack = append(stack, &stackItem{node: n.SkipRange, visitor: v})

	case *ast.NoSkipRange:
		// nothing to do

	case *ast.SetNoSkipRange:
		stack = append(stack, &stackItem{node: n.NoSkipRange, visitor: v})

	case *ast.DropTable:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.RenameTable:
		for i := len(n.Tos) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Tos[i], visitor: v})
		}

	case *ast.RenameTableTo:
		stack = append(stack, &stackItem{node: n.New, visitor: v})
		stack = append(stack, &stackItem{node: n.Old, visitor: v})

	case *ast.CreateIndex:
		stack = append(stack, &stackItem{node: n.InterleaveIn, visitor: v})
		stack = append(stack, &stackItem{node: n.Storing, visitor: v})
		for i := len(n.Keys) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Keys[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.TableName, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.CreateVectorIndex:
		stack = append(stack, &stackItem{node: n.Options, visitor: v})
		stack = append(stack, &stackItem{node: n.Where, visitor: v})
		stack = append(stack, &stackItem{node: n.ColumnName, visitor: v})
		stack = append(stack, &stackItem{node: n.TableName, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.CreateChangeStream:
		stack = append(stack, &stackItem{node: n.Options, visitor: v})
		stack = append(stack, &stackItem{node: n.For, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.ChangeStreamForAll:
		// nothing to do

	case *ast.ChangeStreamForTables:
		for i := len(n.Tables) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Tables[i], visitor: v})
		}

	case *ast.ChangeStreamForTable:
		for i := len(n.Columns) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Columns[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.TableName, visitor: v})

	case *ast.ChangeStreamSetFor:
		stack = append(stack, &stackItem{node: n.For, visitor: v})

	case *ast.ChangeStreamDropForAll:
		// nothing to do

	case *ast.ChangeStreamSetOptions:
		stack = append(stack, &stackItem{node: n.Options, visitor: v})

	case *ast.Storing:
		for i := len(n.Columns) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Columns[i], visitor: v})
		}

	case *ast.InterleaveIn:
		stack = append(stack, &stackItem{node: n.TableName, visitor: v})

	case *ast.AddStoredColumn:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.DropStoredColumn:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.DropIndex:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.DropVectorIndex:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.DropSequence:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.CreateRole:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.DropRole:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.DropChangeStream:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.Grant:
		for i := len(n.Roles) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Roles[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.Privilege, visitor: v})

	case *ast.Revoke:
		for i := len(n.Roles) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Roles[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.Privilege, visitor: v})

	case *ast.PrivilegeOnTable:
		for i := len(n.Names) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Names[i], visitor: v})
		}
		for i := len(n.Privileges) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Privileges[i], visitor: v})
		}

	case *ast.SelectPrivilege:
		for i := len(n.Columns) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Columns[i], visitor: v})
		}

	case *ast.InsertPrivilege:
		for i := len(n.Columns) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Columns[i], visitor: v})
		}

	case *ast.UpdatePrivilege:
		for i := len(n.Columns) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Columns[i], visitor: v})
		}

	case *ast.DeletePrivilege:
		// nothing to do

	case *ast.SelectPrivilegeOnChangeStream:
		for i := len(n.Names) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Names[i], visitor: v})
		}

	case *ast.SelectPrivilegeOnView:
		for i := len(n.Names) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Names[i], visitor: v})
		}

	case *ast.ExecutePrivilegeOnTableFunction:
		for i := len(n.Names) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Names[i], visitor: v})
		}

	case *ast.RolePrivilege:
		for i := len(n.Names) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Names[i], visitor: v})
		}

	case *ast.AlterStatistics:
		stack = append(stack, &stackItem{node: n.Options, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.Analyze:
		// nothing to do

	case *ast.CreateModelColumn:
		stack = append(stack, &stackItem{node: n.Options, visitor: v})
		stack = append(stack, &stackItem{node: n.DataType, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.CreateModelInputOutput:
		for i := len(n.OutputColumns) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.OutputColumns[i], visitor: v})
		}
		for i := len(n.InputColumns) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.InputColumns[i], visitor: v})
		}

	case *ast.CreateModel:
		stack = append(stack, &stackItem{node: n.Options, visitor: v})
		stack = append(stack, &stackItem{node: n.InputOutput, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.AlterModel:
		stack = append(stack, &stackItem{node: n.Options, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.DropModel:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.ScalarSchemaType:
		// nothing to do

	case *ast.SizedSchemaType:
		stack = append(stack, &stackItem{node: n.Size, visitor: v})

	case *ast.ArraySchemaType:
		for i := len(n.NamedArgs) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.NamedArgs[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.Item, visitor: v})

	case *ast.CreateSearchIndex:
		stack = append(stack, &stackItem{node: n.Options, visitor: v})
		stack = append(stack, &stackItem{node: n.Interleave, visitor: v})
		stack = append(stack, &stackItem{node: n.Where, visitor: v})
		stack = append(stack, &stackItem{node: n.OrderBy, visitor: v})
		for i := len(n.PartitionColumns) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.PartitionColumns[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.Storing, visitor: v})
		for i := len(n.TokenListPart) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.TokenListPart[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.TableName, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.DropSearchIndex:
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.AlterSearchIndex:
		stack = append(stack, &stackItem{node: n.IndexAlteration, visitor: v})
		stack = append(stack, &stackItem{node: n.Name, visitor: v})

	case *ast.WithAction:
		stack = append(stack, &stackItem{node: n.Alias, visitor: v})

	case *ast.ThenReturn:
		for i := len(n.Items) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Items[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.WithAction, visitor: v})

	case *ast.Insert:
		stack = append(stack, &stackItem{node: n.ThenReturn, visitor: v})
		stack = append(stack, &stackItem{node: n.Input, visitor: v})
		for i := len(n.Columns) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Columns[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.TableName, visitor: v})

	case *ast.ValuesInput:
		for i := len(n.Rows) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Rows[i], visitor: v})
		}

	case *ast.ValuesRow:
		for i := len(n.Exprs) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Exprs[i], visitor: v})
		}

	case *ast.DefaultExpr:
		stack = append(stack, &stackItem{node: n.Expr, visitor: v})

	case *ast.SubQueryInput:
		stack = append(stack, &stackItem{node: n.Query, visitor: v})

	case *ast.Delete:
		stack = append(stack, &stackItem{node: n.ThenReturn, visitor: v})
		stack = append(stack, &stackItem{node: n.Where, visitor: v})
		stack = append(stack, &stackItem{node: n.As, visitor: v})
		stack = append(stack, &stackItem{node: n.TableName, visitor: v})

	case *ast.Update:
		stack = append(stack, &stackItem{node: n.ThenReturn, visitor: v})
		stack = append(stack, &stackItem{node: n.Where, visitor: v})
		for i := len(n.Updates) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Updates[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.As, visitor: v})
		stack = append(stack, &stackItem{node: n.TableName, visitor: v})

	case *ast.UpdateItem:
		stack = append(stack, &stackItem{node: n.DefaultExpr, visitor: v})
		for i := len(n.Path) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Path[i], visitor: v})
		}

	case *ast.Call:
		for i := len(n.Args) - 1; i >= 0; i-- {
			stack = append(stack, &stackItem{node: n.Args[i], visitor: v})
		}
		stack = append(stack, &stackItem{node: n.Name, visitor: v})
	}
	return stack
}
