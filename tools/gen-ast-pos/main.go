package main

import (
	"bytes"
	"flag"
	"fmt"
	"log"
	"os"
	"regexp"
	"strconv"
	"strings"
	"unicode"

	"github.com/MakeNowJust/heredoc/v2"
	"github.com/cloudspannerecosystem/memefish/tools/util/poslang"
)

var (
	prologue = heredoc.Doc(`
		// Code generated by tools/gen-ast-pos; DO NOT EDIT.

		package ast

		import (
			"github.com/cloudspannerecosystem/memefish/token"
		)
	`)
)

var (
	infile  = flag.String("infile", "", "input filename")
	outfile = flag.String("outfile", "", "output filename")
)

var (
	reNameLine = regexp.MustCompile(`^\s*type\s+(\w+)\s+struct\s*\{`)
	rePosLine  = regexp.MustCompile(`^\s*//\s*pos\s*=\s*(.*)`)
	reEndLine  = regexp.MustCompile(`^\s*//\s*end\s*=\s*(.*)`)
)

type astNode struct {
	name             string
	posExpr, endExpr poslang.PosExpr
}

func main() {
	flag.Parse()

	source, err := os.ReadFile(*infile)
	if err != nil {
		log.Fatal(err)
	}

	var nodes []*astNode

	for _, line := range strings.Split(string(source), "\n") {
		if m := reNameLine.FindStringSubmatch(line); m != nil {
			name := m[1]
			nodes = append(nodes, &astNode{name: name})
			continue
		}

		if m := rePosLine.FindStringSubmatch(line); m != nil {
			e := m[1]
			expr, err := poslang.Parse(e)
			if err != nil {
				log.Fatal(err)
			}
			nodes[len(nodes)-1].posExpr = expr
			continue
		}

		if m := reEndLine.FindStringSubmatch(line); m != nil {
			e := m[1]
			expr, err := poslang.Parse(e)
			if err != nil {
				log.Fatal(err)
			}
			nodes[len(nodes)-1].endExpr = expr
			continue
		}
	}

	var buffer bytes.Buffer
	buffer.WriteString(prologue)

	for _, node := range nodes {
		v := string(unicode.ToLower(rune(node.name[0])))

		fmt.Fprintln(&buffer)
		fmt.Fprintf(&buffer, "func (%s *%s) Pos() token.Pos {\n", v, node.name)
		fmt.Fprintf(&buffer, "\treturn %s\n", posExprToGo(v, node.posExpr))
		fmt.Fprintf(&buffer, "}\n")
		fmt.Fprintln(&buffer)
		fmt.Fprintf(&buffer, "func (%s *%s) End() token.Pos {\n", v, node.name)
		fmt.Fprintf(&buffer, "\treturn %s\n", posExprToGo(v, node.endExpr))
		fmt.Fprintf(&buffer, "}\n")
	}

	if *outfile == "" {
		fmt.Print(buffer.String())
		return
	}

	err = os.WriteFile(*outfile, buffer.Bytes(), 0666)
	if err != nil {
		log.Fatal(err)
	}
}

func posExprToGo(v string, expr poslang.PosExpr) string {
	switch e := expr.(type) {
	case *poslang.Var:
		return v + "." + e.Name
	case *poslang.NodePos:
		return "nodePos(" + nodeExprToGo(v, e.Expr) + ")"
	case *poslang.NodeEnd:
		return "nodeEnd(" + nodeExprToGo(v, e.Expr) + ")"
	case *poslang.PosChoice:
		ss := make([]string, 0, len(e.Exprs))
		for _, p := range e.Exprs {
			ss = append(ss, posExprToGo(v, p))
		}
		return "posChoice(" + strings.Join(ss, ", ") + ")"
	case *poslang.PosAdd:
		return "posAdd(" + posExprToGo(v, e.Expr) + ", " + intExprToGo(v, e.Value) + ")"
	default:
		panic("unsupported")
	}
}

func nodeExprToGo(v string, expr poslang.NodeExpr) string {
	switch e := expr.(type) {
	case *poslang.Var:
		return "wrapNode(" + v + "." + e.Name + ")"
	case *poslang.NodeChoice:
		ss := make([]string, 0, len(e.Exprs))
		for _, n := range e.Exprs {
			ss = append(ss, nodeExprToGo(v, n))
		}
		return "nodeChoice(" + strings.Join(ss, ", ") + ")"
	case *poslang.NodeSliceIndex:
		return "nodeSliceIndex(" + nodeSliceExprToGo(v, e.Expr) + ", " + intExprToGo(v, e.Index) + ")"
	case *poslang.NodeSliceLast:
		return "nodeSliceLast(" + nodeSliceExprToGo(v, e.Expr) + ")"
	default:
		panic("unsupported")
	}
}

func nodeSliceExprToGo(v string, expr poslang.NodeSliceExpr) string {
	switch e := expr.(type) {
	case *poslang.Var:
		return v + "." + e.Name
	default:
		panic("unsupported")
	}
}

func intExprToGo(v string, expr poslang.IntExpr) string {
	switch e := expr.(type) {
	case *poslang.Len:
		return "len(" + stringExprToGo(v, e.Expr) + ")"
	case *poslang.IntLiteral:
		return strconv.Itoa(e.Value)
	case *poslang.IfThenElse:
		return "ifThenElse(" + boolExprToGo(v, e.Cond) + ", " + intExprToGo(v, e.Then) + ", " + intExprToGo(v, e.Else) + ")"
	default:
		panic("unsupported")
	}
}

func stringExprToGo(v string, expr poslang.StringExpr) string {
	switch e := expr.(type) {
	case *poslang.Var:
		return v + "." + e.Name
	default:
		panic("unsupported")
	}
}

func boolExprToGo(v string, expr poslang.BoolExpr) string {
	switch e := expr.(type) {
	case *poslang.Var:
		return v + "." + e.Name
	default:
		panic("unsupported")
	}
}
